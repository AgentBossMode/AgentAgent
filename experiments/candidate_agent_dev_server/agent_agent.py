from dotenv import load_dotenv
load_dotenv()
import logging
from bs4 import BeautifulSoup
import html2text
import httpx
import yaml
import json
from pydantic import Field, BaseModel
from langgraph.graph import MessagesState, StateGraph, START, END
from typing import List
from langgraph.checkpoint.memory import MemorySaver
from langchain_core.prompts import PromptTemplate
from langchain_core.messages import HumanMessage, SystemMessage, AIMessage, ToolMessage
from langchain_openai import ChatOpenAI
from langgraph.types import Send
import operator
from typing import Annotated
from typing import NamedTuple



# Set up the logger
logging.basicConfig(
    level=logging.INFO,  # Set to DEBUG for detailed logs
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        # logging.FileHandler("scraper.log"),  # Log to a file
        logging.StreamHandler()  # Log to console
    ]
)

logger = logging.getLogger(__name__)


def fetch_documents(url: str) -> str:
    """Fetch a document from a URL and return the markdownified text.

    Args:
        url (satr): The URL of the document to fetch.

    Returns:
        str: The markdownified text of the document.
    """
    httpx_client = httpx.Client(follow_redirects=True, timeout=10)

    try:
        response = httpx_client.get(url, timeout=10)
        response.raise_for_status()
        html_content = response
        soup = BeautifulSoup(html_content, 'html.parser')
        a_tags = soup.find_all('a')
        for a_tag in a_tags:
            a_tag.decompose()
        
        img_tags = soup.find_all('img')
        for img_tag in img_tags:
            img_tag.decompose()

        target_div = soup.find('div', class_= "theme-doc-markdown markdown") #langchain
        
        if not target_div:
            target_div = soup.find('article') #langraph
        
        if not target_div:
            return
        
        return html2text.html2text(str(target_div))
    except (httpx.HTTPStatusError, httpx.RequestError) as e:
        return f"Encountered an HTTP error: {str(e)}"
    
    
agent_architecture_urls = ["https://langchain-ai.github.io/langgraph/tutorials/multi_agent/multi-agent-collaboration",
 "https://langchain-ai.github.io/langgraph/tutorials/multi_agent/agent_supervisor",
 "https://langchain-ai.github.io/langgraph/tutorials/plan-and-execute/plan-and-execute",
 "https://langchain-ai.github.io/langgraph/tutorials/self-discover/self-discover",
 "https://langchain-ai.github.io/langgraph/tutorials/multi_agent/hierarchical_agent_teams"
]


template = """Your job is to get information from a user about what kind of agent they wish to build.

You should get the following information from them:

- What the objective of the agent is
- Various responsibilities of the agent 

- What model provider to use

If you are not able to discern this info, ask them to clarify! Do not attempt to wildly guess.

After you are able to discern all the information, call the tool AgentInstruction """

class AgentInstructions(BaseModel):
    """Instructions on how to build the Agent"""
    objective: str = Field(description= "What is the primary objective of the agent")
    responsibilities: List[str] = Field(description= "What are the various responsibilities of the agent which it needs to fulfill")
    model_provider : str = Field(description= "Which model provider powers the LLM workload? eg. OpenAI/Claude/CodeLLama etc.")

class ArchEvaluationReport(BaseModel):
    """Class to represent the architecture evaluation report"""
    name: str = Field(description="Name of the agent architecture being evaluated")
    highlights: str = Field(description="Concise summary of the architecture in 5 lines")
    evaluation_score: int = Field(description="evaluation of suitability of the agentic_architecture against user requirements from 1-10, 1 being least relevant to 10 being most relevant")
    justification: str = Field( description="Justification for the score")
    tailored_design: str = Field(description="Tailored design using the architecture")
    
class ArchEvaluationWithUrl(NamedTuple):
    url: str
    report: ArchEvaluationReport

class AgentBuilderState(MessagesState):
    agent_instructions: AgentInstructions = Field("the requirement analysis generated by the model.")
    arch_evaluation_reports: Annotated[List[ArchEvaluationWithUrl], operator.add] = Field("list of agent architectures suggested in map-reduce step")
    best_agent_architecture: ArchEvaluationWithUrl = Field("The agent architecture best suited to above requirements")
    yaml_code: str = Field("The YAML code generated")
    python_code: str = Field("The Python code generated")
    reactflow_json: str = Field("The ReactFlow code generated")

class ArchitectureEvaluationState(MessagesState):
    agent_instructions: AgentInstructions = Field("the requirement analysis generated by the model.")
    url: str = Field("url of the agent architecture to evaluate against")

llm = ChatOpenAI(temperature=0, model="gpt-4o-mini", streaming=True)

def requirement_analysis_node(state: AgentBuilderState):
    
    llm_with_tool = llm.bind_tools([AgentInstructions])
    response = llm_with_tool.invoke([SystemMessage(content=template)] + state["messages"])
    
      # Construct the final answer from the arguments of the last tool call  
    if len(response.tool_calls) == 0:
        return {"messages": [response]}
    
    agent_instructions = response.tool_calls[0]
    agent_instructions = AgentInstructions(**agent_instructions["args"])
    
    return {"messages": [response], "agent_instructions": agent_instructions}

ARCH_EVALUATION_PROMPT = PromptTemplate.from_template(
    """
You are tasked with assessing the provided agentic architecture documentation to determine its relevance and applicability to the user requirements outlined below.

Agentic Architecture Documentation:

{agent_architecture}

User Requirements:

Objectives: {objective}

Responsibilities: {responsibilities}

Deliverables: 

Provide your evaluation in the following structured format:

1. Name of the Agent Architecture

2. A concise name for the architecture being evaluated.

3. 2-3 Line Highlights about the Architecture

4. Summarize the key features and unique aspects of the architecture.

5. Relevance Score (1-10) : Provide a numerical score (1 being not relevant, 10 being highly relevant) based on the alignment between the architecture and the user requirements.

6. Justification for the Score: A brief rationale (5-10 lines) explaining why you gave this score, citing specific advantages or misalignments with the user requirements.

7. Tailored Design Using the Architecture for the User Requirements: Propose an implementation of the architecture that aligns with the userâ€™s objectives and responsibilities. Be precise and action-focused in detailing how it can meet their needs.
"""
)

def architecture_evaluation_map_node(state: AgentBuilderState):
    return [Send("evaluate_against_architecture", {"agent_instructions": state["agent_instructions"], "url": url}) for url in agent_architecture_urls]

def route_state(state: AgentBuilderState):
    messages = state["messages"]
    if isinstance(messages[-1], AIMessage) and messages[-1].tool_calls:
        return "add_tool_message"
    elif not isinstance(messages[-1], HumanMessage):
        return END
    return "requirement_analysis"

def evaluate_against_architecture(state: ArchitectureEvaluationState):
    agent_instructions: AgentInstructions = state["agent_instructions"]
    url: str = state["url"]
    llm_with_structured_output = llm.with_structured_output(ArchEvaluationReport)
    archEvaluationReport: ArchEvaluationReport = llm_with_structured_output.invoke(
        [SystemMessage(content=ARCH_EVALUATION_PROMPT.format(agent_architecture=fetch_documents(url),
                                                             objective=agent_instructions.objective,
                                                             responsibilities=agent_instructions.responsibilities))])
    
    return {
        "messages": [AIMessage(content=f"Evaluated architecture {url}, arch_name: {archEvaluationReport.name}")],
        "arch_evaluation_reports": [ArchEvaluationWithUrl(url,archEvaluationReport)],
    }

def best_architecture(state: AgentBuilderState):
    """Select the best architecture based on the evaluation reports."""
    # Sort the architectures based on their evaluation scores
    arch_reports : List[ArchEvaluationWithUrl] = state["arch_evaluation_reports"]
    sorted_architectures = sorted(arch_reports, key=lambda x: x.report.evaluation_score , reverse=True)
    
    # Select the best architecture (the first one in the sorted list)
    best_architecture = sorted_architectures[0]
    
    print("found the best architecture")
    
    # Return the best architecture as the output
    return {
        "messages": [AIMessage(content="Best architecture selected!")],
        "best_agent_architecture": best_architecture,
    }

AGENT_KERNEL_PROMPT = PromptTemplate.from_template(
    """
        You are tasked with designing a langgraph StateGraph object that implements the {agent_architecture_name} architecture tailored to meet the user requirements outlined below.
        <Requirements>
        Objectives: {objective}
        Responsibilities: {responsibilities}
        </Requirements>

        <Documentation for {agent_architecture_name}>
        {agent_architecture}
        </Documentation for {agent_architecture_name}>
        
        Suggestion on how to implement the architecture in a way that meets the user requirements:
        {agent_tailored}
        
        Output needs to be a compiled StateGraph object.
        
        Important to Note:
        * Do not hallucinate when writing StateGraph related code, refer to the documentation provided.
        * Understand the concept of the architecture, and refer to the examples of code. Now generate your own code tailored to requirements.
    """)

def agent_kernel_builder(state: AgentBuilderState):
    """Build the agent kernel using the best architecture."""
    best_architecture: ArchEvaluationWithUrl = state["best_agent_architecture"]
    agent_instructions : AgentInstructions = state["agent_instructions"]
    langgraph_glossary_url = "https://langchain-ai.github.io/langgraph/concepts/low_level/"
    agent_architecture_url : str = best_architecture.url
    agent_architecture_report : ArchEvaluationReport = best_architecture.report
    # agent_architecture_report.name
    #agent_architecture_report.highlights
    #agent_architecture_report.justification
    #agent_architecture_report.tailored_design
    
    response =  llm.invoke([SystemMessage(content=AGENT_KERNEL_PROMPT.format(
        objective=agent_instructions.objective,
        responsibilities=agent_instructions.responsibilities,
        # langgraph_glossary=fetch_documents(langgraph_glossary_url),
        agent_tailored=agent_architecture_report.tailored_design,
        agent_architecture_name = agent_architecture_report.name,
        agent_architecture=fetch_documents(agent_architecture_url)))])
    
    # Return the generated agent kernel as the output
    return {
        "messages": [AIMessage(content="Generated agent kernel code!")],
        "python_code": response.content,
    }
    

CODE_TO_YAML_PROMPT = PromptTemplate.from_template("""
You are tasked with converting the following stategraph compilation code into a YAML. 

NOTE: the YAML should always contain START and END nodes.

The code is as follows:
{code_snippet}

OUTPUT: YAML. Do not include any other text or explanation. dO not include any code blocks. DONT ADD ```YAML Do not include any comments. Do not include any other text or explanation. Just the YAML.

EXAMPLE OUTPUT:

stategraph:
  state:
    overall_state:
      type: TypedDict
      fields:
        foo: str
        user_input: str
        graph_output: str
    input_schema:
      type: TypedDict
      fields:
        user_input: str
    output_schema:
      type: TypedDict
      fields:
        graph_output: str
    private_schema:
      type: TypedDict
      fields:
        bar: str
    config_schema:
      type: TypedDict
      fields:
        llm: str
  nodes:
    - name: START
        function: null
    - name: END
        function: null
    - name: node_1
      function: node_1_function
    - name: node_2
      function: node_2_function
    - name: node_3
      function: node_3_function
  edges:
    - from: START
      to: node_1
    - from: node_1
      to: node_2
    - from: node_2
      to: node_3
    - from: node_3
      to: END
  conditional_edges:
    - from: node_1
      routing_function: routing_function_name
      mapping:
        True: node_2
        False: node_3
  messages:
    - type: list
      reducer: add_messages
  command:
    - node: my_node
      update:
        foo: "bar"
      goto: my_other_node
  recursion_limit: 25
  interrupt:
    - node: human_approval_node
      question: "Is it ok to continue?"
  subgraphs:
    - name: subgraph_1
      nodes:
        - name: subgraph_node
          function: subgraph_node_function
      edges:
        - from: subgraph_node
          to: END          
""")

def code_to_yaml_node(state: AgentBuilderState):
    """Convert the generated code to YAML."""
    yaml_code_ouptut = llm.invoke([SystemMessage(content=CODE_TO_YAML_PROMPT.format(code_snippet=state["python_code"]))])
    
    # Return the YAML code as the output
    return {
        "messages": [AIMessage(content="Generated YAML code!")],
        "yaml_code": yaml_code_ouptut.content,
    }

def yaml_to_tree_positions(yaml_data):
    reactflow = {"nodes": [], "edges": []}
    nodes = yaml_data.get("nodes", [])
    edges = yaml_data.get("edges", [])
    conditional_edges = yaml_data.get("conditional_edges", [])

    # Create a mapping of edges to track parent-child relationships
    children_map = {}
    for edge in edges:
        parent = edge["from"]
        child = edge["to"]
        if parent not in children_map:
            children_map[parent] = []
        children_map[parent].append(child)

    # Include conditional edges in the children map
    for cond_edge in conditional_edges:
        parent = cond_edge["from"]
        mapping = cond_edge["mapping"]

        for condition, child in mapping.items():
            if parent not in children_map:
                children_map[parent] = []
            children_map[parent].append(child)

    # Helper function to assign positions recursively
    def assign_positions(node_id, depth, x_offset, x_step, visited):
        # Prevent infinite recursion by checking if the node is already visited
        if node_id in visited:
            return
        visited.add(node_id)

        if node_id not in node_positions:
            node_positions[node_id] = {"x": x_offset, "y": depth * y_spacing}
            # Add node to ReactFlow nodes
            node = next((n for n in nodes if n["name"] == node_id), None)
            if node:
                reactflow["nodes"].append({
                    "id": node_id,
                    "data": {
                        "function": node.get("function", ""),
                        "reducer": node.get("reducer", ""),
                        "label": node_id.replace("_", " ").title()
                    },
                    "position": {"x": x_offset, "y": depth * y_spacing}
                })

        # Recurse to children
        if node_id in children_map:
            num_children = len(children_map[node_id])
            child_x_offset = x_offset - (x_step * (num_children - 1)) / 2
            for index, child_id in enumerate(children_map[node_id]):
                assign_positions(
                    child_id, depth + 1, child_x_offset + (index * x_step), x_step // 2, visited
                )

    # Root node position configuration
    y_spacing = 150  # Vertical distance between levels
    x_step = 400  # Horizontal distance between child nodes
    node_positions = {}

    # Assume START is the root node
    visited_nodes = set()  # Track visited nodes to avoid infinite loops
    assign_positions("START", 0, 0, x_step, visited_nodes)

    # Add regular edges to ReactFlow
    for edge in edges:
        reactflow["edges"].append({
            "id": f'{edge["from"]}_to_{edge["to"]}',
            "source": edge["from"],
            "target": edge["to"]
        })

    # Add conditional edges to ReactFlow
    for cond_edge in conditional_edges:
        parent = cond_edge["from"]
        routing_function = cond_edge["routing_function"]
        mapping = cond_edge["mapping"]

        for condition, target in mapping.items():
            reactflow["edges"].append({
                "id": f'{parent}_to_{target}_condition_{condition}',
                "source": parent,
                "target": target,
                "animated": True,  # Make edge animated
                "label": f'{routing_function} [{condition}]'
            })

    return reactflow


def yaml_to_reactflow_node(state: AgentBuilderState):
    """Convert the YAML code to ReactFlow."""
    
    # Parse YAML
    parsed_yaml = yaml.safe_load(state["yaml_code"])

    # Convert to ReactFlow JSON with tree layout
    reactflow_json = yaml_to_tree_positions(parsed_yaml["stategraph"])
    
    # Return the ReactFlow code as the output
    return {
        "messages": [AIMessage(content="Generated ReactFlow JSON!")],
        "reactflow_json": json.dumps(reactflow_json, indent=2),
    }

workflow = StateGraph(AgentBuilderState)
workflow.add_node("requirement_analysis", requirement_analysis_node)
workflow.add_node("evaluate_against_architecture", evaluate_against_architecture)
workflow.add_node("best_architecture", best_architecture)
workflow.add_node("agent_kernel_builder", agent_kernel_builder)
workflow.add_node("code_to_yaml", code_to_yaml_node)
workflow.add_node("yaml_to_reactflow", yaml_to_reactflow_node)

@workflow.add_node
def add_tool_message(state: AgentBuilderState):
    
   
    return {
        "messages": [
            ToolMessage(
                content="Requirements generated!",
                tool_call_id=state["messages"][-1].tool_calls[0]["id"],
            )
        ]
    }


workflow.add_edge("yaml_to_reactflow", END)
workflow.add_edge("code_to_yaml", "yaml_to_reactflow")
workflow.add_edge("agent_kernel_builder", "code_to_yaml")
workflow.add_edge("best_architecture", "agent_kernel_builder")
workflow.add_edge("evaluate_against_architecture", "best_architecture")
workflow.add_conditional_edges("add_tool_message", architecture_evaluation_map_node,["evaluate_against_architecture"])
workflow.add_conditional_edges("requirement_analysis", route_state, ["add_tool_message", "requirement_analysis", END])
workflow.add_edge(START, "requirement_analysis")
infograph = workflow.compile()